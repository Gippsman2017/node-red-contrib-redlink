<script type="text/javascript">
    const outputNames = {
        receive: 'Receive',
        manual:  'Notify',
        failure: 'Failure',
        config:  'Config',
        stats:   'Stats',
        debug:   'Debug'
    };

    function getOutputs(receive, manual, failure, stats, debug) {
        const outputs = [];
        if (receive) { outputs.push(outputNames.receive); }
        if (manual)  { outputs.push(outputNames.manual);  }
        if (failure) { outputs.push(outputNames.failure); }
        if (stats)   { outputs.push(outputNames.stats);   }
        if (debug)   { outputs.push(outputNames.debug);   }
        return outputs;
    }

    function getProducerOutputs(outputObj) { //receive, notify, failure, debug
        const outputs = [];
        if (!outputObj.sendOnly) { //show both receive and notify
            outputs.push(outputNames.receive);
            outputs.push(outputNames.manual); //todo rename this to notify- we are showing notify in both maul and auto read
        }
        if(outputObj.failure){ outputs.push(outputNames.failure); }
        if(outputObj.config) { outputs.push(outputNames.config);  }
        if(outputObj.stats)  { outputs.push(outputNames.stats);   }
        if(outputObj.debug)  { outputs.push(outputNames.debug);   }
        return outputs;
    }

    function getReplyOutputs(outputObj){
        const outputs = [];
        if(outputObj.debug)  { outputs.push(outputNames.debug);   }
        return outputs;
    }

    function getRandomNumber() {
        return Math.floor((0x99999 - 0x10000) * Math.random()).toString(16);
    }

    //see https://github.com/node-red/node-red/wiki/Design:-Editable-port-labels
    function getNodeRedOutputObject(existingOutputs, newOutputs) {
        console.log('existingOutputs:', existingOutputs, 'newOutputs:', newOutputs);
        const nodeRedOutputObject = {};
        //possible scenarios:
        //1. output position remains the same
        //2. output is reordered
        //3. output removed
        //4. output added
        existingOutputs.forEach((existingOutput, index) => { // handle cases 1, 2, 3
            nodeRedOutputObject[index] = newOutputs.indexOf(existingOutput);
        });
        newOutputs.forEach((newOutput, index) => { // handle case 4
            if (existingOutputs.indexOf(newOutput) === -1) { //newly added
                nodeRedOutputObject[getRandomNumber()] = index;
            }
        });
        return nodeRedOutputObject;
    }
</script>

<script type="text/x-red" data-template-name="redlink store">
    <div class="form-row">
        <label for="node-input-meshName"><i class="icon-tag"></i> Mesh Name </label>
        <input type="text" id="node-input-meshName" placeholder="Mesh Name">
    </div>

    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Store Name </label>
        <input type="text" id="node-input-name" placeholder="Store Name">
    </div>

    <div class="form-row">
        <label for="node-input-listenAddress"><i class="icon-tag"></i> Listen Address </label>
        <input type="text" id="node-input-listenAddress" placeholder="Address" style="width:150px; height:28px;">
        <label for="node-input-listenPort"><i class="icon-tag"></i> Listen Port </label>
        <input type="text" id="node-input-listenPort" placeholder="Port" style="width:60px; height:28px;">
    </div>

    <div class="form-row node-input-headers-container-row">
        <label><i class="icon-tag"></i> North Peers (IP and Port)</label><br>
        <ol id="node-input-headers-container"></ol>
    </div>

    <div class="form-row">
        <label for="node-input-notifyInterval"><i class="fa fa-hourglass-1"></i> Notify Interval (s)</label>
        <input type="text" id="node-input-notifyInterval" placeholder="Notify Interval in sec">
    </div>


</script>

<script type="text/x-red" data-help-name="redlink store"></script>
<!--redlink store-->
<script type="text/javascript">
    const validateIpAddress = function (ipAddress) { //from https://www.w3resource.com/javascript/form/ip-address-validation.php

        return (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ipAddress))
    };
    const validatePositiveNumber = function (port) {
        return RED.validators.number(port) && (port >= 0);
    };
    var headerTypes = [ //TODO clean this up- copied from http-node most of these are not used
        {value: "other", label: RED._("node-red:httpin.label.other"), icon: "red/images/typedInput/az.png"}
    ];
    var contentTypes = [ //TODO clean this up- copied from http-node most of these are not used
        {value: "application/json", label: "application/json", hasValue: false},
        {value: "application/xml",  label: "application/xml", hasValue: false},
        {value: "text/css",         label: "text/css", hasValue: false},
        {value: "text/html",        label: "text/html", hasValue: false},
        {value: "text/plain",       label: "text/plain", hasValue: false},
        {value: "image/gif",        label: "image/gif", hasValue: false},
        {value: "image/png",        label: "image/png", hasValue: false},
        {value: "other", label: RED._("node-red:httpin.label.other"), icon: "red/images/typedInput/09.png"}
    ];

    RED.nodes.registerType('redlink store', {
        category: 'redlink',
        color: "#f56042",
        inputs: 1,
        outputs: 3, //debug
        defaults: {
            listenAddress: { value: ''   },
            listenPort:    { value: 2000, required: true, validate: validatePositiveNumber  },
            peerAddress:   { value: '0.0.0.0', required: true, validate: validateIpAddress  },
            peerPort:      { value: 443,  required: true, validate: validatePositiveNumber   },
            headers:       { value: [] },
            name:          { value: '',   required: true },
            meshName:      { value: 'mesh0', required: true },
            notifyInterval:{ value: 15, required: true/*, validate: validatePositiveNumber*/},
            oldStore:      { value: false }
        },
        icon: "redis.png",
        label: function () {
            return this.name || "";
        },
        labelStyle: function () {
            return this.name ? "node_label_italic" : "";
        },
        oneditprepare: function () {
            $.getJSON('hostname', hostname => {
                console.log('got hostname as:', hostname);
                this.listenAddress = this.listenAddress || hostname;
                $('#node-input-listenAddress').val(this.listenAddress);
            });


            //TODO get all store names in this instance; then validate current store name on change to avoid duplicates
            function resizeRule(rule) {
                var newWidth = rule.width();
                rule.find('.red-ui-typedInput').typedInput("width", (newWidth - 15) / 2);
            }

            var headerList = $("#node-input-headers-container").css('min-height', '10px').css('min-width', '400px').editableList({
                addItem: function (container, i, header) {
                    if (!header.h) {
                        header.h = '127.0.0.1';
                    }
                    if (!header.v) { //todo confirm with John
                        header.v = '2000';
                    }
                    var row = $('<div/>').css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    }).appendTo(container);

                    var propertyName = $('<input/>', {class: "node-input-header-name", type: "text"})
                        .appendTo(row)
                        .typedInput({types: headerTypes});

                    var propertyValue = $('<input/>', {
                        class: "node-input-header-value",
                        type: "text",
                        style: "margin-left: 10px"
                    })
                        .appendTo(row)
                        .typedInput({
                            types:
                                header.h === 'content-type' ? contentTypes : [{
                                    value: "other",
                                    label: "other",
                                    icon: "red/images/typedInput/09.png"
                                }]
                        });

                    var matchedType = headerTypes.filter(function (ht) {
                        return ht.value === header.h
                    });
                    if (matchedType.length === 0) {
                        propertyName.typedInput('type', 'other');
                        propertyName.typedInput('value', header.h);
                        propertyValue.typedInput('value', header.v);
                    } else {
                        propertyName.typedInput('type', header.h);

                        if (header.h === "content-type") {
                            matchedType = contentTypes.filter(function (ct) {
                                return ct.value === header.v;
                            });
                            if (matchedType.length === 0) {
                                propertyValue.typedInput('type', 'other');
                                propertyValue.typedInput('value', header.v);
                            } else {
                                propertyValue.typedInput('type', header.v);
                            }
                        } else {
                            propertyValue.typedInput('value', header.v);
                        }
                    }

                    matchedType = headerTypes.filter(function (ht) {
                        return ht.value === header.h
                    });
                    if (matchedType.length === 0) {
                        propertyName.typedInput('type', 'other');
                        propertyName.typedInput('value', header.h);
                    } else {
                        propertyName.typedInput('type', header.h);
                    }

                    propertyName.on('change', function (event) {
                        var type = propertyName.typedInput('type');
                        if (type === 'content-type') {
                            propertyValue.typedInput('types', contentTypes);
                        } else {
                            propertyValue.typedInput('types', [{
                                value: "other",
                                label: "other",
                                icon: "red/images/typedInput/09.png"
                            }]);
                        }
                    });


                    resizeRule(container);
                },
                resizeItem: resizeRule,
                removable: true
            });
            if (this.headers && this.headers.length > 0) {
                this.headers.forEach((header) => {
                    const ip = header.ip;
                    const port = header.port;
                    headerList.editableList('addItem', {h: ip, v: port});
                });
            } else if (!this.oldStore) {
                console.log('newStore:', this.oldStore);
                $.getJSON('north-peers', northies => {
                    console.log('northies:', northies);
                    northies.map(northie => {
                        console.log(northie);
                        headerList.editableList('addItem', {h: northie.address, v: northie.port});
                    });
                });
            }
        },
        oneditsave: function () {
            var headers = $("#node-input-headers-container").editableList('items');
            var node = this;
            node.headers = [];
            node.oldStore = true;
            headers.each(function (i) {
                var header = $(this);
                var keyType = header.find(".node-input-header-name").typedInput('type');
                var ip = header.find(".node-input-header-name").typedInput('value');
                var valueType = header.find(".node-input-header-value").typedInput('type');
                var port = header.find(".node-input-header-value").typedInput('value');
                var key = keyType;
                var value = valueType;
                if (keyType === 'other') {
                    key = ip;
                }
                if (valueType === 'other') {
                    value = port;
                }
                if (key !== '') {
                    node.headers.push({ip, port})
                    // node.headers[key] = value;
                }
            });

        },
        oneditresize: function (size) {
            var rows = $("#dialog-form>div:not(.node-input-headers-container-row)");
            var height = size.height;
            for (var i = 0; i < rows.size(); i++) {
                height -= $(rows[i]).outerHeight(true);
            }
            var editorRow = $("#dialog-form>div.node-input-headers-container-row");
            height -= (parseInt(editorRow.css("marginTop")) + parseInt(editorRow.css("marginBottom")));
            height = 240; //Cludge for too many rows John 
            $("#node-input-headers-container").editableList('height', height);
        }

    });
</script>

<script type="text/x-red" data-template-name="redlink producer">
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Name </label>
        <input type="text" id="node-input-name" placeholder="name">
                        <input type="hidden" id="node-input-outputs"/>

    <div class="form-row" id="producer-store-div">
        <label for="node-input-producerStoreName"><i class="fa fa-ellipsis-v"></i> Store Name</label>
        <select id="node-input-producerStoreName">
        </select>
    </div>
    <div class="form-row" id="producer-consumer-div">
        <label for="node-input-producerConsumer"><i class="fa fa-ellipsis-v"></i> Destination Service</label>
        <select id="node-input-producerConsumer">
        </select>
    </div>
    <div class="form-row">
        <label style="width:100%; border-bottom:1px solid #eee;"><span>Advanced</span></label>
    </div>
        <div class="form-row">
        <label for="node-input-showDebug"><i class="fa fa-stack-exchange"></i> Show Debug</label>
        <input type="checkbox" id="node-input-showDebug">
    </div>
    <div class="form-row">
        <label style="width:100%; border-bottom:1px solid #eee;"><em><span>Send</span></em></label>
    </div>
        <div class="form-row">
        <label for="node-input-producerETT"><i class="fa fa-times"></i> ETT</label>
        <input type="text" id="node-input-producerETT" placeholder="ETT">
    </div>
    <div class="form-row">
        <label for="node-input-priority"><i class="fa fa-arrow-up"></i> Priority</label>
        <input type="text" id="node-input-priority" style="width:30px; height:25px;"/>&nbsp;<br/>
    </div>
    <div class="form-row">
        <label for="node-input-timeout"><i class="fa fa-times"></i> Timeout</label>
        <input type="text" id="node-input-timeout" placeholder="Timeout">
    </div>
    <div class="form-row">
        <label for="node-input-sendOnly"><i class="fa fa-angle-double-right"></i> Send Only</label>
        <input type="checkbox" id="node-input-sendOnly" placeholder="Send Only">
    </div>
    <div id="producer-receive">
        <div class="form-row">
            <label style="width:100%; border-bottom:1px solid #eee;"><em><span>Receive</span></em></label>
        </div>
        <div class="form-row">
            <label for="node-input-manualRead"><i class="fa fa-male"></i> Manual Read</label>
            <input type="checkbox" id="node-input-manualRead" placeholder="Manual Read">
        </div>
        <div id="rate-limit-send-receive">
            <div class="form-row">
                <label><i class="fa fa-sliders"></i> Rate Limit Received Messages</label>
                <select id="node-input-rateTypeSendReceive" style="width:270px !important">
                    <option value="none" data-i18n="delay.limitall">None</option>
                    <option value="rateLimit" data-i18n="delay.limittopic">Rate Limit</option>
                </select>
            </div>
            <div class="form-row" id="rate-limit-details-send-receive">
                <label for="node-input-rate-send-receive">Rate<i class="fa fa-clock-o"></i> <span data-i18n="delay.rate"></span></label>
                <input type="text" id="node-input-rateSendReceive" placeholder="1" style="text-align:end; width:40px !important">
                <label for="node-input-rateUnitsSendReceive">msg(s) per<span data-i18n="delay.msgper"></span></label>
                <input type="text" id="node-input-nbRateUnitsSendReceive" placeholder="1" style="text-align:end; width:40px !important">
                <select id="node-input-rateUnitsSendReceive" style="width:90px !important">
                  <option value="second" data-i18n="delay.label.units.second.singular">Seconds</option>
                  <option value="minute" data-i18n="delay.label.units.minute.singular">Minutes</option>
                  <option value="hour" data-i18n="delay.label.units.hour.singular">Hours</option>
                  <option value="day" data-i18n="delay.label.units.day.singular">Days</option>
                </select>
            </div>
        </div>
    </div>


</script>
<!--redlink producer-->
<script type="text/javascript">
    RED.nodes.registerType('redlink producer', {
        category: 'redlink',
        color:    "#f56042",
        inputs:   1,
        outputs:  3,
        defaults: {
            name: {value: 'REDLink producer'},
            producerStoreName:      {value: '', required: true},
            producerConsumer:       {value: '', required: false},
            producerTTL:            {value: 15, required: true},
            producerETT:            {value: 5 * 60, required: true},
            priority:               {value: 0},
            timeout:                {value: -1},//TODO check with John,
            sendOnly:               {value: false},
            manualRead:             {value: false},
            rateTypeSendReceive:    {value: "none"},
            rateSendReceive:        {value: 1},
            rateUnitsSendReceive:   {value: "second"},
            nbRateUnitsSendReceive: {value: ''},
//            server:                 {value: "tcp://localhost:9660"},
            topic:                  {value: ""},
            cmd:                    {value: "send"},
            private:                {value: false},
            ttl:                    {value: null},
            tba:                    {value: null},
            showDebug:              {value: false},
            outputs:                {value: 3},
        },
        outputLabels: function (index) {
            const labels = getProducerOutputs({
                sendOnly: this.sendOnly,
                debug:    this.showDebug,
                failure:  true
            });
            return labels[index];
        },
        icon: "arrow-in.png",
        align: "right",
        label: function () {
            return this.name || "";
        },
        labelStyle: function () {
            return this.name ? "node_label_italic" : "";
        },
        oneditsave: function () {
            let newSendOnly = $('#node-input-sendOnly').is(":checked");
            let newDebug    = $('#node-input-showDebug').is(":checked");
            console.log('going to call getoutputs for existing ports with sendOnly: ', this.sendOnly, 'showDebug:', this.showDebug);
            const existingOutputs = getProducerOutputs({
                sendOnly: this.sendOnly,
                debug:    this.showDebug,
                failure:  true
            });
            console.log('got existing outputs as:', existingOutputs);
            // getOutputs(!this.sendOnly, this.manualRead, true, this.showStats, this.showDebug);
            console.log('going to call getoutputs for new with sendOnly: ', newSendOnly, 'showDebug:', newDebug);
            const newOutputs =  getProducerOutputs({
                sendOnly: newSendOnly,
                debug:    newDebug,
                failure:  true
            });
            console.log('got new outputs as:', newOutputs);
            var nodeRedOutputsObject = getNodeRedOutputObject(existingOutputs, newOutputs);
            $("#node-input-outputs").val(JSON.stringify(nodeRedOutputsObject));
            console.log('\n\n\n\n\n on editsave val of $("#node-input-outputs"):', $("#node-input-outputs").val());
        },
        oneditprepare: function () {
            const selectedStore = this.producerStoreName;
            console.log('selectedStore:', selectedStore);

            if (!this.sendOnly) { $('#producer-receive').show(); }
                           else { $('#producer-receive').hide(); }
            
            $('#node-input-sendOnly').click(function () {
                console.log('this.checked:', this.checked);
                if (!this.checked) { $('#producer-receive').show(); } 
                              else { $('#producer-receive').hide(); }
            });


            function repopulateStores() { //todo refactor
                let storeElement = $("#node-input-producerStoreName");
                storeElement.find('option').remove().end();
                $.getJSON('all-store-names', stores => {
                    let selectionSet = false;
                    console.log('\n\n\n\nstores from get call in producer:', stores);
                    $.each(stores, function (index, obj) {
                        console.log('selectedStore:', selectedStore, 'obj:', obj, 'selectedStore === obj:', selectedStore === obj);
                        if (selectedStore === obj) {
                            selectionSet = true;
                            console.log('selectionSet:', selectionSet);
                        }
                        storeElement.append($('<option>', {
                            value: obj,
                            text: obj,
                            selected: selectedStore === obj
                        }));
                    });
                    if (!selectionSet) {
                        console.log(' selection not set for meshes in producer- going to select element at zero', $("#node-input-producerStoreName option:first").val());

                        var options = $('#node-input-producerStoreName option');

                        var values = $.map(options, function (option) {
                            return option.value;
                        });
                        console.log('all store values:', values);
                        // $("#node-input-producerStoreName").prop("selectedIndex", 0);
                        $("#node-input-producerStoreName option:first").attr('selected', 'selected');
                        console.log('after setting selected to zero, the selected store in producer is:', $("#node-input-producerMeshName").children("option:selected").val());
                        repopulateConsumers();
                    }
                });

            }

            repopulateStores();

            $('#node-input-rateTypeSendReceive').change(function () {
                if (this.value === 'none')      { $('#rate-limit-details-send-receive').hide(); }
           else if (this.value === 'rateLimit') { $('#rate-limit-details-send-receive').show();
                }
            });

            const selectedConsumer = this.producerConsumer;
            console.log('selectedStore:', selectedStore);

            function repopulateConsumers() {
                console.log('in repopulateConsumers the selected producerStoreName is:', $("#node-input-producerStoreName").children("option:selected").val());
                let consumerElement = $("#node-input-producerConsumer");
                consumerElement.find('option').remove().end();
                console.log("Handler for .change() called.");
                // console.log('value of node-input-producerStoreName:', );
                const storeName = $("#node-input-producerStoreName").children("option:selected").val() || selectedStore;
                $.getJSON('consumers', {"producer": this.name, "store": storeName}, stores => {
                    console.log('\n\n\n\nstores from get call:', stores);
                    $.each(stores, function (index, obj) {
                        console.log('index:', index, ' obj:', obj);
                        consumerElement.append($('<option>', {
                            value: obj,
                            text: obj,
                            selected: selectedConsumer === obj
                        }));
                    });
                });
            }

            $("#node-input-producerStoreName").change(() => { repopulateConsumers(); });
        }
    });
</script>

<script type="text/x-red" data-template-name="redlink consumer">
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Consumer / Service name</label>
        <input type="text" id="node-input-name" placeholder="Consumer/Service">
        <input type="hidden" id="node-input-outputs"/>
    </div>
    <div class="form-row" id="consumer-mesh-div">
        <label for="node-input-consumerMeshName"><i class="fa fa-ellipsis-v"></i> Mesh Name</label>
        <select id="node-input-consumerMeshName">
        </select>
    </div>

    <div class="form-row" id="consumer-store-div">
        <label for="node-input-consumerStoreName"><i class="fa fa-ellipsis-v"></i> Store Name</label>
        <select id="node-input-consumerStoreName">
        </select>
    </div>
    </div>
    <hr align="middle"/>
    <div class="form-row">
        <label style="width:100%; border-bottom:1px solid #eee;"><span>Advanced</span></label>
    </div>
    <div class="form-row">
        <label for="node-input-showStatsReceiveSend"><i class="fa fa-bar-chart"></i> Show Stats</label>
        <input type="checkbox" id="node-input-showStatsReceiveSend">
        <div class="form-row" id="stats-frequency-receive-send">
            <label for="node-input-statsFrequencyReceiveSend">Emit stats every </label>
            <input type="text" id="node-input-statsFrequencyReceiveSend" placeholder="1" style="text-align:end; width:40px !important"> second(s)
        </div>
        <label for="node-input-showDebugReceiveSend"><i class="fa fa-stack-exchange"></i> Show Debug</label>
        <input type="checkbox" id="node-input-showDebugReceiveSend">
    </div>
    <div class="form-row">
        <label style="width:100%; border-bottom:1px solid #eee;"><em><span>Receive</span></em></label>
    </div>
        <div class="form-row" id="inTransitLimitBlock">
        <label for="node-input-intransit"><i class="fa fa-plane"></i> In Transit Limit</label>
        <input type="text" id="node-input-intransit" placeholder="In Transit Limit">
    </div>

    <div class="form-row">
        <label for="node-input-manualReadReceiveSend"><i class="fa fa-male"></i> Manual Read</label>
        <input type="checkbox" id="node-input-manualReadReceiveSend" placeholder="Manual Read">
    </div>

    <div id="rate-limit-receive-send">
        <div class="form-row">
            <label><i class="fa fa-sliders"></i> Rate Limit Received Messages</label>
            <select id="node-input-rateTypeReceiveSend" style="width:270px !important">
                <option value="none" data-i18n="delay.limitall">None</option>
                <option value="rateLimit" data-i18n="delay.limittopic">Rate Limit</option>
            </select>
        </div>
        <div class="form-row" id="rate-limit-details-receive-send">
            <label for="node-input-rate-receive-send">Rate<i class="fa fa-clock-o"></i> <span data-i18n="delay.rate"></span></label>
            <input type="text" id="node-input-rateReceiveSend" placeholder="1" style="text-align:end; width:40px !important">
            <label for="node-input-rateUnitsReceiveSend">msg(s) per<span data-i18n="delay.msgper"></span></label>
            <input type="text" id="node-input-nbRateUnitsReceiveSend" placeholder="1" style="text-align:end; width:40px !important">
            <select id="node-input-rateUnitsReceiveSend" style="width:90px !important">
              <option value="second" data-i18n="delay.label.units.second.singular">Seconds</option>
              <option value="minute" data-i18n="delay.label.units.minute.singular">Minutes</option>
              <option value="hour" data-i18n="delay.label.units.hour.singular">Hours</option>
              <option value="day" data-i18n="delay.label.units.day.singular">Days</option>
            </select>
        </div>
    </div>

</script>
<!--redlink consumer-->
<script type="text/javascript">
    RED.nodes.registerType('redlink consumer', {
        category: 'redlink',
        color: "#f56042",
        inputs: 1,
        outputs: 2,
        defaults: {
            name: {value: '', required: true},
            consumerMeshName: {value: '', required: true},
            consumerStoreName: {value: '', required: true},
            intransit: {
                value: 1, validate: function (v) {
                    return RED.validators.number(v) && (v >= 0);
                }
            },
            manualReadReceiveSend: {value: false},
            rateTypeReceiveSend: {value: "none"},
            rateReceiveSend: {value: 1},
            rateUnitsReceiveSend: {value: "second"},
            nbRateUnitsReceiveSend: {value: ''},
            server: {value: "tcp://localhost:9660"},
            topicReceiveSend: {value: ""},
            cmd: {value: "read"},
            showStatsReceiveSend: {value: false},
            statsFrequencyReceiveSend: {
                value: 0, validate: function (v) {
                    return RED.validators.number(v) && (v >= 0);
                }
            },
            showDebugReceiveSend: {value: false},
            outputs: {value: 2}
        },
        outputLabels: function (index) {
            var labels = getOutputs(true, this.manualReadReceiveSend, true, this.showStatsReceiveSend, this.showDebugReceiveSend);
            return labels[index];
        },
        icon: "arrow-in.png",
        label: function () {
            return this.name || "";
        },
        labelStyle: function () {
            return this.name ? "node_label_italic" : "";
        },
        oneditprepare: function () {
            const selectedStore = this.consumerStoreName;
            const selectedMesh = this.consumerMeshName;
            console.log('selectedStore:', selectedStore);

            function repopulateStores() {
                console.log('in repopulateStores the selected consumerMeshName is:', $("#node-input-consumerMeshName").children("option:selected").val());
                let storeElement = $("#node-input-consumerStoreName");
                storeElement.find('option').remove().end();
                console.log("Handler for .change() called.");
                // console.log('value of node-input-producerStoreName:', );
                const meshName = $("#node-input-consumerMeshName").children("option:selected").val() || selectedMesh;
                $.getJSON('store-names', {"producer": this.name, "mesh": meshName}, stores => {
                    console.log('\n\n\n\nstores from get call:', stores);
                    $.each(stores, function (index, obj) {
                        console.log('index:', index, ' obj:', obj);
                        storeElement.append($('<option>', {
                            value: obj,
                            text: obj,
                            selected: selectedStore === obj
                        }));
                    });
                });
            }

            $("#node-input-consumerMeshName").change(() => {
                repopulateStores();
            });

            let meshesElement = $("#node-input-consumerMeshName");

            $.getJSON('mesh-names', meshes => {
                let selectionSet = false;
                console.log('\n\n\n\nmeshes from get call:', meshes);
                $.each(meshes, function (index, obj) {
                    if (selectedMesh === obj) {
                        selectionSet = true;
                    }
                    console.log('index:', index, ' obj:', obj);
                    meshesElement.append($('<option>', {
                        value: obj,
                        text: obj,
                        selected: selectedMesh === obj
                    }));
                });
                if (!selectionSet) {
                    console.log(' selection not set for meshes in consumer- going to select element at zero', $("#node-input-consumerMeshName option:first").val());

                    var options = $('#node-input-consumerMeshName option');

                    var values = $.map(options, function (option) {
                        return option.value;
                    });
                    console.log('all mesh values:', values);
                    // $("#node-input-producerStoreName").prop("selectedIndex", 0);
                    $("#node-input-consumerMeshName option:first").attr('selected', 'selected');
                    console.log('after settign selected to zero, the selected store in producer is:', $("#node-input-consumerMeshName").children("option:selected").val());
                    repopulateStores();
                }
            });


            $('#node-input-rateTypeReceiveSend').change(function () {
                if (this.value == 'none') {
                    $('#rate-limit-details-receive-send').hide();
                } else if (this.value == 'rateLimit') {
                    $('#rate-limit-details-receive-send').show();
                }
            });
            if (this.rateTypeReceiveSend) {
                $('#rate-limit-details-receive-send').show();
            } else {
                $('#rate-limit-details-receive-send').hide();
            }
            if (this.showStatsReceiveSend) {
                $('#stats-frequency-receive-send').show();
            } else {
                $('#stats-frequency-receive-send').hide();
            }
            $('#node-input-showStatsReceiveSend').click(function () {
                if (this.checked) {
                    $('#stats-frequency-receive-send').show();
                } else {
                    $('#stats-frequency-receive-send').hide();
                }
            });

        },
        oneditsave: function () {
            const newManualRead = $('#node-input-manualReadReceiveSend').is(":checked");
            const newShowStats = $('#node-input-showStatsReceiveSend').is(":checked");
            const newShowDebug = $('#node-input-showDebugReceiveSend').is(":checked");
            const existingOutputs = getOutputs(true, this.manualReadReceiveSend, true, this.showStatsReceiveSend, this.showDebugReceiveSend);
            const newOutputs = getOutputs(true, newManualRead, true, newShowStats, newShowDebug);
            var nodeRedOutputsObject = getNodeRedOutputObject(existingOutputs, newOutputs);
            $("#node-input-outputs").val(JSON.stringify(nodeRedOutputsObject));
            console.log('\n\n\n\n\n on editsave val of $("#node-input-outputs"):', $("#node-input-outputs").val());
            console.log('this.outputLabels:', this.outputLabels);
        }
    });
</script>

