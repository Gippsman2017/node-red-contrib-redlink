
<script type="text/javascript">
    const outputNames = {
        receive: 'Receive',
        manual:  'Notify',
        failure: 'Failure',
        config:  'Config',
        stats:   'Stats',
        debug:   'Debug',
        command: 'Command', //store
        registration: 'Notify' //store
    };

    function getString(value){
        switch(value){
            case true:
            case "true":
                return "true";
            default:
                return "false";
        }
    }

    function getStoreName(qualifiedStore){
        let storeName ='';
        if (qualifiedStore && qualifiedStore.trim().toLowerCase()!=='please select a store'){
            if (qualifiedStore.indexOf(':')!=-1) { storeName = '(' + qualifiedStore.substring(qualifiedStore.indexOf(':')+1, qualifiedStore.length) +')' } 
        }
        return storeName;
    }

    function getOutputs(receive, manual, failure, stats, debug) {
        const outputs = [];
        if (receive) { outputs.push(outputNames.receive); }
        if (manual)  { outputs.push(outputNames.manual);  }
        if (failure) { outputs.push(outputNames.failure); }
        if (stats)   { outputs.push(outputNames.stats);   }
        if (debug)   { outputs.push(outputNames.debug);   }
        return outputs;
    }

    function getProducerOutputs(outputObj) { //receive, notify, failure, debug
        const outputs = [];
        if (!outputObj.sendOnly) { //show both receive and notify
            outputs.push(outputNames.receive);
            outputs.push(outputNames.manual);
        }
        if(outputObj.failure){ outputs.push(outputNames.failure); }
        if(outputObj.config) { outputs.push(outputNames.config);  }
        if(outputObj.stats)  { outputs.push(outputNames.stats);   }
        if(outputObj.debug)  { outputs.push(outputNames.debug);   }
        return outputs;
    }

    function getStoreOutputs(outputObj){
        const outputs = [];
        if(outputObj.command)  { outputs.push(outputNames.command);   }
        if(outputObj.registration)  { outputs.push(outputNames.registration);   }
        if(outputObj.debug)  { outputs.push(outputNames.debug);   }
        return outputs;
    }

    function getRandomNumber() {
        return Math.floor((0x99999 - 0x10000) * Math.random()).toString(16);
    }

    //see https://github.com/node-red/node-red/wiki/Design:-Editable-port-labels
    function getNodeRedOutputObject(existingOutputs, newOutputs) {
        const nodeRedOutputObject = {};
        //possible scenarios:
        //1. output position remains the same
        //2. output is reordered
        //3. output removed
        //4. output added
        existingOutputs.forEach(function (existingOutput, index) { // handle cases 1, 2, 3
            nodeRedOutputObject[index] = newOutputs.indexOf(existingOutput);
        });
        newOutputs.forEach(function (newOutput, index) { // handle case 4
          if (existingOutputs.indexOf(newOutput) === -1) { //newly added
              nodeRedOutputObject[getRandomNumber()] = index;
          }
        });
        return nodeRedOutputObject;
    }
</script>

<script type="text/x-red" data-template-name="redlink store">
    <div class="form-row">
        <label for="node-input-meshName"><i class="fa fa-plus-square-o"></i> Mesh Name </label>
        <input type="text" id="node-input-meshName" placeholder="Mesh Name">
    </div>

    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-link"></i> Store Name </label>
        <input type="text" id="node-input-name" placeholder="Store Name">
        <input type="hidden" id="node-input-outputs"/>
        <input type="hidden" id="node-input-userKey"/>
        <input type="hidden" id="node-input-userCertificate"/>
    </div>

    <div class="form-row">
        <label for="node-input-listenAddress"><i class="fa fa-assistive-listening-systems"></i> Listen Address </label>
        <input type="text" id="node-input-listenAddress" placeholder="Address" style="width:150px; height:28px;">
    </div>
    <div class="form-row">
        <label for="node-input-listenPort"><i class="fa fa-assistive-listening-systems"></i> Listen Port </label>
        <input type="text" id="node-input-listenPort" placeholder="Port" style="width:60px; height:28px;">
    </div>
    <div class="form-row">   
        <label for="node-input-southInsert"><i class="fa fa-long-arrow-down"></i> South Inserts</label>
        <input type="checkbox" id="node-input-southInsert" checked>
    </div>

    <div class="form-row">
        <label for="node-input-interStoreLB"><i class="fa fa-male"></i> Load Balance Interstore Messaging</label>
        <input type="checkbox" id="node-input-interStoreLB" placeholder="Load Balance Interstore Messaging">
    </div>
    
    <div class="form-row node-input-headers-container-row">
        <label><i class="fa fa-cloud-upload "></i> North Peers (IP, Port and Redistribute)</label><br>
        <ol id="node-input-headers-container"></ol>
    </div>

    <div class="form-row">
        <label style="width:100%; border-bottom:1px solid #eee;"><span>Advanced</span></label>
    </div>
        <div class="form-row">
        <label for="node-input-showDebug"><i class="fa fa-bug"></i> Show Debug</label>
        <input type="checkbox" id="node-input-showDebug">
    </div>
    <div class="form-row">
        <label for="node-input-showRegistration"><i class="fa fa-stack-exchange"></i> Show New Message Notifications</label>
        <input type="checkbox" id="node-input-showRegistration">
    </div>

    <div class="form-row">
        <label for="node-input-isUserCertificate"><i class="fa fa-user"></i> User specified certificate</label>
        <input type="checkbox" id="node-input-isUserCertificate">
            <div class="form-row" id="userCertificateDiv">
                <label for="userKeyText"><i class="fa fa-key"></i> User key (Paste Only)</label>
                <input type="text" id="userKeyText">
                <label for="userCertificateText"><i class="fa fa-certificate"></i> User certificate (Paste Only)</label>
                <input type="text" id="userCertificateText">
            </div>
    </div>
</script>

<script type="text/x-red" data-help-name="redlink store">
  <p>The Store node is the interconnection point between all nodes in the network.</p>

  <p><b>UI Configuration</b></p>
  <p><b> Mesh Name </b> A qualifier to logically group a set of stores. Producers and consumers specify a store qualified with mesh name</p>
  <p><b>  Store Name</b> The name of this store</p>
  <p><b>  Listen Address</b> The IP/hostname on which this store listens to for registration messages and routing traffic</p>
  <p><b>  Listen Port</b> The port on which this store listens to for registration messages and routing traffic</p>
  <p><b>  South Insert</b> This flag set allows inserts of globalConsumers sent from South bound stores into this store</p>
  <p><b>  Loadbalance Interstore Messaging</b> This flag set causes the store to randomly loadbalance notifies to stores that have the same service registrations instead of sending notifies in parallel</p>
  <p><b>  North Peers</b> List of stores that this store is connected to. Each of these stores will be north of the current sore. Use this to build a mesh, also has a redistribute flag to allow/stop this store from informing interconnected store(s) on a per North store connection .</p>
  <p><b>  Show New Message Notifications</b> Advanced- use when debugging to show new message notifications flowing through this store</p>
  <p><b>  Show Debug</b> Advanced- use to turn on the debug port to output extra information</p>

  <p><b>Message Configuration </b></p>
  <p><b> msg.topic</b> Can be </p>
  <p><b>listServices</b>  Simple list of all services that this store can see</p>
  <p><b>listRegistrations</b> Contains the routing of this store</p>
  <p><b>listStore</b> Contains all of the relevant data that this store messages has in transit, including notifies and messages</p>
  <p><b>flushStore</b> Be careful, it completely wipes the store, so, it can leave remnant process in a bad state</p>
  <p>Output 1 displays the above data</p>
  <p>Output 2 displays the transit notifies and registrations for this store</p>
  <p>Output 3 displays debug information</p>

</script>

<script type="text/x-red" data-help-name="redlink store"></script>
<!--redlink store-->
<script type="text/javascript">
    const validateIpAddress = function (ipAddress) { //from https://www.w3resource.com/javascript/form/ip-address-validation.php
        return (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ipAddress))
    };
    const validatePositiveNumber = function (port) {
        return RED.validators.number(port) && (port >= 0);
    };
    var headerTypes = [ //TODO clean this up- copied from http-node most of these are not used
        {value: "other", label: RED._("node-red:httpin.label.other"), icon: "red/images/typedInput/az.png"}
    ];
    var contentTypes = [ //TODO clean this up- copied from http-node most of these are not used
        {value: "application/json", label: "application/json", hasValue: false},
        {value: "application/xml",  label: "application/xml", hasValue: false},
        {value: "text/css",         label: "text/css", hasValue: false},
        {value: "text/html",        label: "text/html", hasValue: false},
        {value: "text/plain",       label: "text/plain", hasValue: false},
        {value: "image/gif",        label: "image/gif", hasValue: false},
        {value: "image/png",        label: "image/png", hasValue: false},
        {value: "other", label: RED._("node-red:httpin.label.other"), icon: "red/images/typedInput/09.png"}
    ];
    var redistributeTypes = [
        {value: "false", label: "false", hasValue: false},
        {value: "true", label: "true", hasValue: false}
        ];
    RED.nodes.registerType('redlink store', {
        category: 'redlink',
        color: "#f56042",
        inputs: 1,
        outputs: 1, //command
        defaults: {
            listenAddress: { value: ''   },
            listenPort:    { value: 2000, required: true, validate: validatePositiveNumber  },
            southInsert:   { value: true },
            peerAddress:   { value: '0.0.0.0', required: true, validate: validateIpAddress  },
            peerPort:      { value: 443,  required: true, validate: validatePositiveNumber   },
            headers:       { value: [] },
            name:          { value: '',   required: true },
            meshName:      { value: 'mesh0', required: true },
            interStoreLB:  { value: false },
            oldStore:      { value: false },
            showRegistration : { value: false },
            showDebug : { value: false },
            outputs: { value: 1 },
            isUserCertificate : { value: false},
            userKey : { value :''},
            userCertificate : { value: ''}
        },
        outputLabels: function (index) {
            const labels = getStoreOutputs({
                command: true,
                registration:  this.showRegistration,
                southinsert: this.southInsert,
                interStoreLB: this.interStoreLB,
                debug:    this.showDebug
            });
            return labels[index];
        },
        icon: "redis.png",
        label: function () {
            return (this.name || "")+(this.meshName?'('+this.meshName+')':'');
        },
        labelStyle: function () {
            return this.name ? "node_label_italic" : "";
        },
        oneditprepare: function () {
            if (this.isUserCertificate) {
                $('#userKeyText').val('****');
                $('#userCertificateText').val('****');
                $('#userCertificateDiv').show();
            } 
          else 
            {
                $('#userCertificateDiv').hide();
            }
            $('#node-input-isUserCertificate').click( function () {
                if (this.checked) {
                    $('#userCertificateDiv').show();
                    $('#node-input-userKeyText').val('');
                    $('#node-input-userCertificateText').val('');
                } 
              else 
                {
                    $('#userCertificateDiv').hide();
                }
            });
            function preventTyping(e) { //disallow typing in key, cert text fields
                e.preventDefault();
            }
            $('#userKeyText').on('paste',function(e){
                const pastedData = e.originalEvent.clipboardData.getData('text');
                $("#node-input-userKey").val(pastedData);
                $("#userKeyText").val('****');
                e.preventDefault();
                // alert('Working!'+content);
            });
            $('#userKeyText').on('keypress',preventTyping);
            $('#userCertificateText').on('paste',function(e){
                const pastedData = e.originalEvent.clipboardData.getData('text');
                $("#node-input-userCertificate").val(pastedData);
                $("#userCertificateText").val('****');
                e.preventDefault();
                // alert('Working!'+content);
            });
            $('#userCertificateText').on('keypress',preventTyping);

            $.getJSON('hostname', hostname => {
                this.listenAddress = this.listenAddress || hostname;
                $('#node-input-listenAddress').val(this.listenAddress);
            });
            //TODO get all store names in this instance; then validate current store name on change to avoid duplicates
            function resizeRule(rule) {
                var newWidth = rule.width();
                rule.find('.red-ui-typedInput').typedInput("width", (newWidth - 15) / 3);
            }

            var headerList = $("#node-input-headers-container").css('min-height', '10px').css('min-width', '400px').editableList({
                addItem: function (container, i, header) {
                    if (!header.h) { header.h = 'localhost'; }
                    if (!header.v) { header.v = '2000'; }
                    if(typeof header.d === 'undefined') { header.d = "false"; } 
                                                   else { header.d = getString(header.d) }
                    var row = $('<div/>').css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    }).appendTo(container);

                    var propertyName = $('<input/>', {class: "node-input-header-name", type: "text"})
                        .appendTo(row)
                        .typedInput({types: headerTypes});

                    var propertyValue = $('<input/>', {
                        class: "node-input-header-value",
                        type: "text",
                        style: "margin-left: 10px"
                    }).appendTo(row)
                        .typedInput({
                            types:
                                header.h === 'content-type' ? contentTypes : [{
                                    value: "other",
                                    label: "other",
                                    icon: "red/images/typedInput/09.png"
                                }]
                        });

                    var redistribute = $('<input/>', {
                        class: "node-input-header-redistribute",
                        type: "text",
                        style: "margin-left: 10px"
                    }).appendTo(row)
                        .typedInput({types: redistributeTypes});

                    var matchedType = headerTypes.filter(function (ht) {
                        return ht.value === header.h
                    });
                    if (matchedType.length === 0) {
                        propertyName.typedInput('type', 'other');
                        propertyName.typedInput('value', header.h);
                        propertyValue.typedInput('value', header.v);
                        redistribute.typedInput('type', header.d);
                    } else {
                        propertyName.typedInput('type', header.h);
                        if (header.h === "content-type") {
                            matchedType = contentTypes.filter(function (ct) {
                                return ct.value === header.v;
                            });
                            if (matchedType.length === 0) {
                                propertyValue.typedInput('type', 'other');
                                propertyValue.typedInput('value', header.v);
                            } else {
                                propertyValue.typedInput('type', header.v);
                            }
                        } else {
                            propertyValue.typedInput('value', header.v);
                        }
                    }

                    matchedType = headerTypes.filter(function (ht) {
                        return ht.value === header.h
                    });
                    if (matchedType.length === 0) {
                        propertyName.typedInput('type', 'other');
                        propertyName.typedInput('value', header.h);
                    } else {
                        propertyName.typedInput('type', header.h);
                    }

                    propertyName.on('change', function (event) {
                        var type = propertyName.typedInput('type');
                        if (type === 'content-type') {
                            propertyValue.typedInput('types', contentTypes);
                        } else {
                            propertyValue.typedInput('types', [{
                                value: "other",
                                label: "other",
                                icon: "red/images/typedInput/09.png"
                            }]);
                        }
                    });


                    resizeRule(container);
                },
                resizeItem: resizeRule,
                removable: true
            });
            if (this.headers && this.headers.length > 0) {
                this.headers.forEach((header) => {
                    const ip = header.ip;
                    const port = header.port;
                    headerList.editableList('addItem', {h: ip, v: port, d: header.redistribute});
                });
            } else if (!this.oldStore) {
                $.getJSON('north-peers', northies => {
                    northies.map(northie => {
                        headerList.editableList('addItem', {h: northie.address, v: northie.port, d: northie.redistribute});
                    });
                });
            }
        },
        oneditsave: function () {
            //outputs begin
            let newSouthInsert = $('#node-input-southInsert').is(":checked");
            let newInterStoreLB = $('#node-input-interStoreLB').is(":checked");
            let newShowRegistration = $('#node-input-showRegistration').is(":checked");
            let newShowDebug    = $('#node-input-showDebug').is(":checked");
            const existingOutputs = getStoreOutputs({
                command: true,
                registration:  this.showRegistration,
                southInsert: this.southInsert,
                interStoreLB: this.interStoreLB,
                debug:  this.showDebug
            });
            // getOutputs(!this.sendOnly, this.manualRead, true, this.showStats, this.showDebug);
            const newOutputs =  getStoreOutputs({
                command: true,
                registration:  newShowRegistration,
                southInsert: newSouthInsert,
                interStoreLB: newInterStoreLB,
                debug:  newShowDebug
            });
            var nodeRedOutputsObject = getNodeRedOutputObject(existingOutputs, newOutputs);
            $("#node-input-outputs").val(JSON.stringify(nodeRedOutputsObject));
            //outputs end

            var headers = $("#node-input-headers-container").editableList('items');
            var node = this;
            node.headers = [];
            node.oldStore = true;
            headers.each(function (i) {
                var header = $(this);
                var keyType = header.find(".node-input-header-name").typedInput('type');
                var ip = header.find(".node-input-header-name").typedInput('value');
                var valueType = header.find(".node-input-header-value").typedInput('type');
                var port = header.find(".node-input-header-value").typedInput('value');
                var redistribute = header.find(".node-input-header-redistribute").typedInput('type');
                redistribute = getString(redistribute);
                var key = keyType;
                var value = valueType;
                if (keyType === 'other') { key = ip; }
                if (valueType === 'other') { value = port; }
                if (key !== '') { node.headers.push({ip, port, redistribute}) }
            });
            //console.log('on save north peers are:', node.headers);
        },
        oneditresize: function (size) {
            var rows = $("#dialog-form>div:not(.node-input-headers-container-row)");
            var height = size.height;
            for (var i = 0; i < rows.size(); i++) { height -= $(rows[i]).outerHeight(true); }
            var editorRow = $("#dialog-form>div.node-input-headers-container-row");
            height -= (parseInt(editorRow.css("marginTop")) + parseInt(editorRow.css("marginBottom")));
            height = 240; //Cludge for too many rows John 
            $("#node-input-headers-container").editableList('height', height);
        }
    });
</script>

<script type="text/x-red" data-template-name="redlink producer">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-sign-out"></i> Name </label>
        <input type="text" id="node-input-name" placeholder="name">
                        <input type="hidden" id="node-input-outputs"/>
    </div>
    <div class="form-row" id="producer-store-div">
        <label for="node-input-producerStoreName"><i class="fa fa-link"></i> Store Name</label>
        <select id="node-input-producerStoreName">
        <option value="" selected>Please select a store</option>
        </select>
    </div>
    <div class="form-row" id="producer-consumer-div">
        <label for="node-input-producerConsumer"><i class="fa fa-gears"></i> Destination Service</label>
        <select id="node-input-producerConsumer">
        </select>
    </div>
    <div class="form-row">
        <label style="width:100%; border-bottom:1px solid #eee;"><span>Advanced</span></label>
    </div>
    <div class="form-row">
        <label for="node-input-showDebug"><i class="fa fa-bug"></i> Show Debug</label>
        <input type="checkbox" id="node-input-showDebug">
    </div>
    <div class="form-row">
        <label style="width:100%; border-bottom:1px solid #eee;"><em><span>Send</span></em></label>
    </div>
        <div class="form-row">
        <label for="node-input-producerETT"><i class="fa fa-times"></i> ETT</label>
        <input type="text" id="node-input-producerETT" placeholder="ETT">
    </div>
    <div class="form-row">
        <label for="node-input-notifyInterval"><i class="fa fa-hourglass-1"></i> Notify Interval (s)</label>
        <input type="text" id="node-input-notifyInterval" placeholder="Notify Interval in sec">
    </div>

    <div class="form-row">
        <label for="node-input-priority"><i class="fa fa-arrow-up"></i> Priority</label>
        <input type="text" id="node-input-priority" style="width:30px; height:25px;"/>&nbsp;<br/>
    </div>

    <div class="form-row">
        <label for="node-input-enforceReversePath"><i class="fa fa-male"></i> Enforce Reverse Path</label>
        <input type="checkbox" id="node-input-enforceReversePath" placeholder="Enforce Reverse Path">
    </div>
    
    <div class="form-row">
        <label for="node-input-sendOnly"><i class="fa fa-angle-double-right"></i> Send Only</label>
        <input type="checkbox" id="node-input-sendOnly" placeholder="Send Only">
    </div>
    <div id="producer-receive">
        <div class="form-row">
            <label style="width:100%; border-bottom:1px solid #eee;"><em><span>Receive</span></em></label>
        </div>
        <div class="form-row">
            <label for="node-input-manualRead"><i class="fa fa-male"></i> Manual Read</label>
            <input type="checkbox" id="node-input-manualRead" placeholder="Manual Read">
        </div>
        <div id="rate-limit-send-receive">
            <div class="form-row">
                <label><i class="fa fa-sliders"></i> Rate Limit Received Messages</label>
                <select id="node-input-rateTypeSendReceive" style="width:270px !important">
                    <option value="none" data-i18n="delay.limitall">None</option>
                    <option value="rateLimit" data-i18n="delay.limittopic">Rate Limit</option>
                </select>
            </div>
            <div class="form-row" id="rate-limit-details-send-receive">
                <label for="node-input-rate-send-receive">Rate<i class="fa fa-clock-o"></i> <span data-i18n="delay.rate"></span></label>
                <input type="text" id="node-input-rateSendReceive" placeholder="1" style="text-align:end; width:40px !important">
                <label for="node-input-rateUnitsSendReceive">msg(s) per<span data-i18n="delay.msgper"></span></label>
                <input type="text" id="node-input-nbRateUnitsSendReceive" placeholder="1" style="text-align:end; width:40px !important">
                <select id="node-input-rateUnitsSendReceive" style="width:90px !important">
                  <option value="second" data-i18n="delay.label.units.second.singular">Seconds</option>
                  <option value="minute" data-i18n="delay.label.units.minute.singular">Minutes</option>
                  <option value="hour" data-i18n="delay.label.units.hour.singular">Hours</option>
                  <option value="day" data-i18n="delay.label.units.day.singular">Days</option>
                </select>
            </div>
        </div>
    </div>
</script>
<!--redlink producer-->


<script type="text/x-red" data-help-name="redlink producer">
  <p>The Producer node has a number of capabilities that allow you to control the flow of the data to it - in and out.</p>
  <p><b>UI Configuration</b></p>
  <p><b>Name </b> Producer Name</p>
  <p><b>  Store Name</b> Store this producer is connected to. This determines the consumers that this producer can send messages to</p>
  <p><b>  Destination Service</b> The service to send the message to. Note that this can also be set via msg.topic- see Message Configuration below</p>
  <p><b>  Show Debug</b> Turn on the debug port for extra information. This can be useful when developing and troubleshooting</p>
  <p><b>  ETT (Estimated Transaction Time)</b> Time in seconds after which the input message is discarded. A message will be sent out via the failure port</p>
  <p><b>  Notify Interval</b> Time interval in seconds after which target consumers will be notified of unread messages</p>
  <p><b>  Priority</b> Messages with higher priority will be given precedence over those with lower priority. Defaults to zero</p>
  <p><b>  Enforce Reverse Path</b> This forces the consumer to send Read and Reply messages back through all stores that the notify has traversed - defaults to true.</p>
  <p><b>  Send Only</b> A Send Only producer will not expect replies from consumers. Any reply sent to a Send Only producer will be discarded</p>
  <p><b>  Manual Read</b> Check this to read messages manually by injecting the read command in msg.topic- see Message Configuration below</p>
  <p><b>  Rate Limit Received Messages</b> configure this to ensure that the producer reads at specified rate and is not swamped with reply messages</p>
  <p><b>Message Configuration </b></p>
  <p><b> msg.payload </b> Can be a string or object</p>
  <p><b> msg.preserved </b> Preserves data and is stored in the producer until the reply message is received, at this point it is reatached to the msg</p>
  <p><b> msg.topic </b> Can be a service name to send to, however the store must already know about the service being registered.</p>
  <p><b> msg.topic </b> Reserved words are <b>read or  producerReplyRead</b> for the manual read function</p>
  <p><b> msg.enforceReversePath </b> Boolean <b>true or false</b> defaults to true</p>
  
</script>

<script type="text/javascript">
    const validateNotifyAndETT = function () {
        const currentNotify = +($('#node-input-notifyInterval').val() ||  this.notifyInterval);
        const currentETT = +($('#node-input-producerETT').val() || this.producerETT);
        if(currentNotify<0) { return false; }
        const valid = currentETT == -1 || currentETT > currentNotify;
        return valid;
    };

    RED.nodes.registerType('redlink producer', {
        category: 'redlink',
        color:    "#f56042",
        inputs:   1,
        outputs:  3,
        defaults: {
            name: {value: 'REDLink producer'},
            producerStoreName:      {value: '', required: true, validate: function (v) { return v && v.length > 0; } },
            producerConsumer:       {value: '', required: false},
            producerTTL:            {value: 15, required: true},
            producerETT:            {value: 5 * 60, required: true, validate: function (v) { return RED.validators.number(v) && (v >= 0); } },
            priority:               {value: 0},
            timeout:                {value: -1},
            sendOnly:               {value: false},
            manualRead:             {value: false},
            enforceReversePath:     {value: true},
            rateTypeSendReceive:    {value: "none"},
            rateSendReceive:        {value: 1},
            rateUnitsSendReceive:   {value: "second"},
            nbRateUnitsSendReceive: {value: ''},
            topic:                  {value: ""},
            cmd:                    {value: "send"},
            private:                {value: false},
            ttl:                    {value: null},
            tba:                    {value: null},
            showDebug:              {value: false},
            outputs:                {value: 3},
            notifyInterval:{ value: 15, required: true, validate: function (v) { return RED.validators.number(v) && (v >= 0); }
            },
        },
        outputLabels: function (index) {
            const labels = getProducerOutputs({
                sendOnly: this.sendOnly,
                debug:    this.showDebug,
                failure:  true
            });
            return labels[index];
        },
        icon: "arrow-in.png",
        align: "right",
        label: function () { return (this.name || "") + getStoreName(this.producerStoreName); },
        labelStyle: function () { return this.name ? "node_label_italic" : ""; },
        oneditsave: function () {
            let newSendOnly = $('#node-input-sendOnly').is(":checked");
            let newDebug    = $('#node-input-showDebug').is(":checked");
            const existingOutputs = getProducerOutputs({ sendOnly: this.sendOnly, debug: this.showDebug, failure: true });
            // getOutputs(!this.sendOnly, this.manualRead, true, this.showStats, this.showDebug);
            const newOutputs =  getProducerOutputs({ sendOnly: newSendOnly, debug:    newDebug, failure:  true });
            var nodeRedOutputsObject = getNodeRedOutputObject(existingOutputs, newOutputs);
            $("#node-input-outputs").val(JSON.stringify(nodeRedOutputsObject));
        },
        oneditprepare: function () {
            const selectedStore = this.producerStoreName;
            if (!this.sendOnly) { $('#producer-receive').show(); }
                           else { $('#producer-receive').hide(); }
            $('#node-input-sendOnly').click(function () {
                if (!this.checked) { $('#producer-receive').show(); }
                              else { $('#producer-receive').hide(); }
            });
            function repopulateStores() { //todo refactor
                let storeElement = $("#node-input-producerStoreName");
                $.getJSON('all-store-names', stores => {
                    let selectionSet = false;
                    $.each(stores, function (index, obj) {
                        if (selectedStore === obj) { selectionSet = true; }
                        storeElement.append($('<option>', { value: obj, text: obj, selected: selectedStore === obj }));
                    });
                    if (!selectionSet) {
                        $('#node-input-producerStoreName option:selected').removeAttr('selected');
                        $('#node-input-producerStoreName option:nth-child(0)').attr('selected','selected');
                    }else{
                        $('#node-input-producerStoreName').removeClass('input-error');
                    }
                    repopulateConsumers();
                });
            }

            repopulateStores();

            $('#node-input-manualRead').change(function () {
                if (this.checked) { $('#rate-limit-send-receive').hide(); } 
                             else { $('#rate-limit-send-receive').show(); }
            });
            if (this.manualReadReceiveSend) { $('#rate-limit-send-receive').hide(); } 
                                       else { $('#rate-limit-send-receive').show(); }

            $('#node-input-rateTypeSendReceive').change(function () {
                if (this.value === 'none')      { $('#rate-limit-details-send-receive').hide(); }
           else if (this.value === 'rateLimit') { $('#rate-limit-details-send-receive').show();
                }
            });

            const selectedConsumer = this.producerConsumer;
            function repopulateConsumers() {
                const storeName = $("#node-input-producerStoreName").children("option:selected").val() || selectedStore;
                $.getJSON('consumers', {"producer": this.name, "store": storeName}, function (stores) {
                    let consumerElement = $("#node-input-producerConsumer");
                    consumerElement.find('option').remove().end();
                    $.each(stores, function (index, obj) {
                        consumerElement.append($('<option>', { value: obj, text: obj, selected: selectedConsumer === obj }));
                    });
                });
            }
            $("#node-input-producerStoreName").change(function () { repopulateConsumers(); });
        }
    });
</script>

<script type="text/x-red" data-template-name="redlink consumer">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-gears"></i> Service name</label>
        <input type="text" id="node-input-name" placeholder="Consumer/Service">
        <input type="hidden" id="node-input-outputs"/>
    </div>

    <div class="form-row" id="consumer-store-div">
        <label for="node-input-consumerStoreName"><i class="fa fa-link"></i> Store Name</label>
        <select id="node-input-consumerStoreName">
            <option value="" selected>Please select a store</option>
        </select>
    </div>
    </div>
    <hr align="middle"/>
    <div class="form-row">
        <label style="width:100%; border-bottom:1px solid #eee;"><span>Advanced</span></label>
    </div>
    <div class="form-row">
        <label for="node-input-showDebugReceiveSend"><i class="fa fa-bug"></i> Show Debug</label>
        <input type="checkbox" id="node-input-showDebugReceiveSend">
    </div>
        <div class="form-row">
        <label for="node-input-reNotifyInterval"><i class="fa fa-hourglass-1"></i> Re-notify Interval (s)</label>
        <input type="text" id="node-input-reNotifyInterval" placeholder="Re-notify Interval in sec">
    </div>
    <div class="form-row">
        <label style="width:100%; border-bottom:1px solid #eee;"><em><span>Receive</span></em></label>
    </div>
        <div class="form-row" id="inTransitLimitBlock">
        <label for="node-input-intransit"><i class="fa fa-plane"></i> In Transit Limit</label>
        <input type="text" id="node-input-intransit" placeholder="In Transit Limit">
    </div>

    <div class="form-row">
        <label for="node-input-manualReadReceiveSend"><i class="fa fa-male"></i> Manual Read</label>
        <input type="checkbox" id="node-input-manualReadReceiveSend" placeholder="Manual Read">
    </div>

    <div id="rate-limit-receive-send">
        <div class="form-row">
            <label><i class="fa fa-sliders"></i> Rate Limit Received Messages</label>
            <select id="node-input-rateTypeReceiveSend" style="width:270px !important">
                <option value="none" data-i18n="delay.limitall">None</option>
                <option value="rateLimit" data-i18n="delay.limittopic">Rate Limit</option>
            </select>
        </div>
        <div class="form-row" id="rate-limit-details-receive-send">
            <label for="node-input-rate-receive-send">Rate<i class="fa fa-clock-o"></i> <span data-i18n="delay.rate"></span></label>
            <input type="text" id="node-input-rateReceiveSend" placeholder="1" style="text-align:end; width:40px !important">
            <label for="node-input-rateUnitsReceiveSend">msg(s) per<span data-i18n="delay.msgper"></span></label>
            <input type="text" id="node-input-nbRateUnitsReceiveSend" placeholder="1" style="text-align:end; width:40px !important">
            <select id="node-input-rateUnitsReceiveSend" style="width:90px !important">
              <option value="second" data-i18n="delay.label.units.second.singular">Seconds</option>
              <option value="minute" data-i18n="delay.label.units.minute.singular">Minutes</option>
              <option value="hour" data-i18n="delay.label.units.hour.singular">Hours</option>
              <option value="day" data-i18n="delay.label.units.day.singular">Days</option>
            </select>
        </div>
    </div>
</script>
<!--redlink consumer-->
<script type="text/x-red" data-help-name="redlink consumer">
  <p>The Consumer node receives messages from a producer and can send back replies</p>
  <p><b>UI Configuration</b></p>
  <p><b>  Consumer/Service Name </b> The name of this consumer/service</p>
  <p><b>  Mesh Name</b> The name of the mesh that this consumer is a part of. This selection determines the stores visible in the stores drop-down</p>
  <p><b>  Store Name</b> The store that this consumer is connected to. The available stores depend on the mesh chosen</p>
  <p><b>  Show Debug</b> Advanced- use to turn on the debug port to output extra information</p>
  <p><b>  Re-notify interval</b> This timer defines the consumer store update sync for localStoreConsumers reNotifies
  <p><b>  In Transit Limit</b> This is the max number of messages which can be in flight- messages which this consumer has received but are still being processed and haven't been replied to yet. If this limit is exceeded, this consumer will not read/consume messages even if it gets notifications. It will resume reading once the number of messages being processed falls below this threshold. The default value is 1.</p>
  <p><b>  Manual Read</b> Check this to read messages manually by injecting the read command in msg.topic- see Message Configuration below</p>
  <p><b>  Rate Limit Received Messages</b> configure this to ensure that the producer reads at specified rate and is not swamped with reply messages</p>

  <p><b>Message Configuration </b></p>
  <p><b>  msg.topic </b> Reserved words are <b>read</b> for the manual read function</p>
  <p><b>  msg.payload </b> Can be a string or object. To return data back to the producer, you feed back the msg object that is emitted from the receive port, with a new or modified msg.payload, back into the input. The consumer will send it back to the calling producer</p>
  <p><b>  msg.cerror </b> Can be a returned object . Note that if this is set, then the producer will be forced to send the output to its failure output, this allows the consumer to validate data and save the producer from having to check the reply etc.
</script>


<script type="text/javascript">
    RED.nodes.registerType('redlink consumer', {
        category: 'redlink',
        color:    "#f56042",
        inputs:   1,
        outputs:  3,
        defaults: {
            name: {value: '', required: true},
            reNotifyInterval:{ value: 1, required: false, validate: function (v) { return RED.validators.number(v) && (v >= 0); } },
            consumerStoreName: { value: '', required: true, validate: function (v) { return v && v.length > 0; } },
            intransit: { value: 1, validate: function (v) { return RED.validators.number(v) && (v >= 0); } },
            manualReadReceiveSend: {value: false},
            rateTypeReceiveSend: {value: "none"},
            rateReceiveSend: {value: 1},
            rateUnitsReceiveSend: {value: "second"},
            nbRateUnitsReceiveSend: {value: ''},
            topicReceiveSend: {value: ""},
            cmd: {value: "read"},
            showStatsReceiveSend: {value: false},
            statsFrequencyReceiveSend: { value: 0, validate: function (v) { return RED.validators.number(v) && (v >= 0); } },
            showDebugReceiveSend: {value: false},
            outputs: {value: 3}
        },
        outputLabels: function (index) { var labels = getOutputs(true, true, true, this.showStatsReceiveSend, this.showDebugReceiveSend); return labels[index]; },
        icon: "arrow-in.png",
        label: function () { return (this.name || "") + getStoreName(this.consumerStoreName); },
        labelStyle: function () { return this.name ? "node_label_italic" : ""; },
        oneditprepare: function () {
            const selectedStore = this.consumerStoreName;
            function repopulateStores() { //todo refactor
                let storeElement = $("#node-input-consumerStoreName");
                $.getJSON('all-store-names', stores => {
                    let selectionSet = false;
                    $.each(stores, function (index, obj) {
                        if (selectedStore === obj) { selectionSet = true; }
                        storeElement.append($('<option>', { value: obj, text: obj, selected: selectedStore === obj }));
                    });
                    if (!selectionSet) {
                        $('#node-input-consumerStoreName option:selected').removeAttr('selected');
                        $('#node-input-consumerStoreName option:nth-child(0)').attr('selected','selected');
                    }
                  else
                    {
                        $('#node-input-consumerStoreName').removeClass('input-error');
                    }
                });

            }

            repopulateStores();

            $('#node-input-manualReadReceiveSend').change(function () {
                if (this.checked) { $('#rate-limit-receive-send').hide(); } 
                             else { $('#rate-limit-receive-send').show(); }
            });
            if (this.manualReadReceiveSend) { $('#rate-limit-receive-send').hide(); } 
                                       else { $('#rate-limit-receive-send').show(); }

            $('#node-input-rateTypeReceiveSend').change(function () {
                if (this.value == 'none') { $('#rate-limit-details-receive-send').hide(); } 
              else 
                if (this.value == 'rateLimit') { $('#rate-limit-details-receive-send').show(); }
            });
            if (this.rateTypeReceiveSend) { $('#rate-limit-details-receive-send').show(); } 
                                     else { $('#rate-limit-details-receive-send').hide(); }
        },
        oneditsave: function () {
            const newShowStats = false;
            const newShowDebug = $('#node-input-showDebugReceiveSend').is(":checked");
            const existingOutputs = getOutputs(true, true, true, false, this.showDebugReceiveSend);
            const newOutputs = getOutputs(true, true, true, newShowStats, newShowDebug);
            var nodeRedOutputsObject = getNodeRedOutputObject(existingOutputs, newOutputs);
            $("#node-input-outputs").val(JSON.stringify(nodeRedOutputsObject));
        }
    });
</script>


